// #include "../ft_printf.h"


// int main(int ac, char **av)
// {
// 	int hello = -802802;
// 	convert_int(hello, 10);
// 	printf("printf: %d\n", hello);
// 	printf("my: %s\n", g_current_data.str.str);
// 	write(1, g_current_data.str.str, g_current_data.str.len);
// 	return 0;
// }

#include <stdio.h>
#include <stdlib.h>
 
/* длинная арифметика 3^100
   равно 
   515377520732011331036461129765621272702107522001
   515377520732011331036461129765621272702107522001
    */
int main(void) /* C89 ANSI */
{
    int n[100] = { 1 };
    /* число храним в достаточно длинном массиве
       первый элемент станет основанием,
       с которого число будет расти
       в сторону старших разрядов */
    
    int base = 10;
    /* полученное число будет в десятичной системе
       можно устанавливать степени десятки
       100, 1000, 10000 и так далее,
       это повысит скорость вычисления,
       результат будет выглядет одинаково;
       нужно учесть размер одного числа в массиве
       если int, то не более 10000 */
    
    int i, j, flag;
    /* i - внешние счётчики
       j - внутренние счётчики первого уровня
       flag - флажок, который при выводе числа
              помогает пропустить начальные нули в числе
              начальные нули - это разряды, до которых
              число не доросло */
    
    for (i = 0; i < 100; i++) {
        
        for (j = 0; j < 100; j++)
            n[j] *= 3;
        /* умножаем всё число на три,
           как будто в столбик на бумаге,
           для каждого разряда */
            
        for (j = 0; j < 100-1; j++)
            if (n[j] >= base) {
                n[j+1] += n[j] / base;
                n[j] %= base;
            }
        /* для всех разрядов, исключая самый старший,
           выполнить проверку на переполнение;
           
           если переполнение в каком-то из разрядов есть,
           то переполнившую часть перенести
           в соседний, более старший, разряд,
           а в самом разряде оставить остаток,
           который не переполняет разряд;
           
           при переносе переполнившей части
           в более старший соседний разряд,
           она прибавляется к тому, что уже там хранится */
        
    }
    /* умножает число на три сто раз,
       проводя проверки на переполнение его разрядов
       и переносы, в случаях переполнения */
    
    flag = 1;
    /* флаг пропуска начальных нулей
       устанавливается в положение "пропустить" */
    
    for (i = 99; i >= 0; i--) {
        
        if (flag == 1)
            if (n[i] == 0)
                continue;
            else
                flag = 0;
        /* если флаг пропуска начальных нулей
           установлен в положение "пропустить",
           то проверить не началось ли число;
           
           если число началось,
           то есть встречен первый ненулевой разряд,
           то переключить флаг в положение "вывести";
           если число не началось,
           сразу перейти к следующему разряду,
           не выводя ничего */
          
        printf("%d", n[i]);
        /* выводит очередной разряд числа,
           начиная слева */
    }
    /* выводит получившееся число слева направо,
       поразрядно, начиная с первого ненулевого разряда */
    
    putchar('\n');
    /* после числа переводит строку */
    
    exit(EXIT_SUCCESS);
    /* возвращает статус успешного завершения
       в операционную среду */
}